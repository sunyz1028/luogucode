# [P4447 分组](https://www.luogu.com.cn/problem/P4447)
![avatar](https://github.com/sunyz1028/luogucode/blob/master/timu/P4447.png)

## 题目描述
0000.

小可可的学校信息组总共有n 个队员，每个人都有一个实力值a[i]。现在，一年一度的编程大赛就要到了，小可可的学校获得了若干个参赛名额，教练决定把学校信息组的n个队员分成若干个小组去参加这场比赛。

但是每个队员都不会愿意与实力跟自己过于悬殊的队员组队，于是要求分成的每个小组的队员实力值连续，同时，一个队不需要两个实力相同的选手。举个例子：[1,2,3,4,5]是合法的分组方案，因为实力值连续;[1,2,3,5]不是合法的分组方案，因为实力值不连续;[0,1,1,2]同样不是合法的分组方案，因为出现了两个实力值为1 的选手。

如果有小组内人数太少，就会因为时间不够而无法获得高分，于是小可可想让你给出一个合法的分组方案，满足所有人都恰好分到一个小组，使得人数最少的组人数最多，输出人数最少的组人数的最大值。

注意：实力值可能是负数，分组的数量没有限制。

## 输入格式
输入有两行：

第一行一个正整数n，表示队员数量。
第二行有n 个整数，第i 个整数a[i]表示第i 个队员的实力。

## 输出格式
输出一行，包括一个正整数，表示人数最少的组的人数最大值。

输入输出样例
### 输入 
7
4 5 2 3 -4 -3 -5
### 输出
3
### 说明/提示
【样例解释】 分为2 组，一组的队员实力值是4,5,2,3，一组是−4,−3,−5，其中最小的组人数为3，可以发现没有比3 更优的分法了。
【数据范围】
对于100%的数据满足：1≤n≤100000，|a[i]|≤10^9。

本题共10 个测试点，编号为1~10，每个测试点额外保证如下：

1-2 n≤6, 1≤a[i]≤100</br>
3-4 n≤1000, 1≤a[i]≤10^5,且a[i]互不相同</br>
5-6 n≤100000,a[i]互不相同</br>
7-8 n≤100000, 1≤a[i]≤10^5</br>
9-10 n≤100000, |a[i]|≤10^9</br>

***
```c++
#include <bits/stdc++.h>
#define ll long long
using namespace std;
bool cmp(ll a,ll b){
	return a<b;
}
int main(){
	ll n,a[100010]={0},t=0x7fffffffffffffff;
	ll cot=t;
	scanf("%lld",&n);
	map<ll,ll>mp;
	for(ll i=0;i<n;i++){
		scanf("%lld",&a[i]);
		mp[a[i]]++;
	}
	a[n]=t;
	if(n==1){
		printf("1");
		return 0; 
	}	
	sort(a,a+n,cmp);
	for(ll i=0;i<n;i++){
		ll tt=1,tn=a[i];
		ll j=i,flag1=0,flag2=0,flag3=0;
		if(mp[tn]==0)	flag1=1;
		while(mp[tn]>0&&mp[tn+1]>0&&mp[tn]<=mp[tn+1]){
			//if((flag3==0&&mp[tn]==1||mp[tn]>=mp[tn+1])||(flag3==1&&mp[tn]==1||mp[tn]>mp[tn+1])){
				flag2=1;
				//printf("%lld   %lld\n",tn,tn+1);
				mp[tn]--;
				tt++;
				tn++;
				flag3=1;
			//}
			
		}
		if(flag1==0&&flag2==0&&mp[j+1]==0){
			mp[tn]--;
			cot=1;
			continue;
		}	
		if(flag1==0&&flag2==1){//printf("***%lld**\n",tn);
			mp[tn]--;
			cot=min(tt,cot);
		}	
	}
	printf("%lld",cot);
	return 0;
}
```
