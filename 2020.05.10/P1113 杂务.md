# [P1113 杂务](https://www.luogu.com.cn/problem/P1113)

## 题目描述

`John`的农场在给奶牛挤奶前有很多杂务要完成，每一项杂务都需要一定的时间来完成它。比如：他们要将奶牛集合起来，将他们赶进牛棚，为奶牛清洗乳房以及一些其它工作。尽早将所有杂务完成是必要的，因为这样才有更多时间挤出更多的牛奶。当然，有些杂务必须在另一些杂务完成的情况下才能进行。比如：只有将奶牛赶进牛棚才能开始为它清洗乳房，还有在未给奶牛清洗乳房之前不能挤奶。我们把这些工作称为完成本项工作的准备工作。至少有一项杂务不要求有准备工作，这个可以最早着手完成的工作，标记为杂务11。`John`有需要完成的n*n*个杂务的清单，并且这份清单是有一定顺序的，杂务k(k>1)*k*(*k*>1)的准备工作只可能在杂务11至k-1*k*−1中。

写一个程序从11到n*n*读入每个杂务的工作说明。计算出所有杂务都被完成的最短时间。当然互相没有关系的杂务可以同时工作，并且，你可以假定`John`的农场有足够多的工人来同时完成任意多项任务。

## 输入格式

第1行：一个整数n*n*，必须完成的杂务的数目(3 \le n \le 10,0003≤*n*≤10,000)；

第22至(n+1)(*n*+1)行： 共有n*n*行，每行有一些用11个空格隔开的整数，分别表示：

\* 工作序号(11至n*n*,在输入文件中是有序的)；

\* 完成工作所需要的时间len(1 \le len \le 100)*l**e**n*(1≤*l**e**n*≤100)；

\* 一些必须完成的准备工作，总数不超过100100个，由一个数字00结束。有些杂务没有需要准备的工作只描述一个单独的00，整个输入文件中不会出现多余的空格。

## 输出格式

一个整数，表示完成所有杂务所需的最短时间。

## 输入输出样例

**输入 #1**复制

```
7
1 5 0
2 2 1 0
3 3 2 0
4 6 1 0
5 1 2 4 0
6 8 2 4 0
7 4 3 5 6 0
```

**输出 #1**复制

```
23
```



***

拓扑排序。

用数组储存需要该前置任务的工作，先把每个需要前驱的值算出来，之后再找出最大完成时间。

***



```c++
#include <bits/stdc++.h>
using namespace std;
int n,xu,len[10010],cot[10010],pre,tim[10010],rst;
vector<int> p[10010];
queue<int> q;
int main(){
	scanf("%d",&n);
	for(int i=1;i<=n;i++){
		scanf("%d",&xu);
		scanf("%d",&len[xu]);
		while(1){
			scanf("%d",&pre);
			if(pre==0)	break;
			else{
				p[pre].push_back(xu);
				cot[xu]++;
			} 
		}
	}
	for(int i=1;i<=n;i++){
		if(!cot[i]){
			q.push(i);
			tim[i]=len[i];
		}	
	}
	while(!q.empty()){
		int now=q.front();
		q.pop();
		for(int i=0;i<p[now].size();i++){
			int t=p[now][i];
			tim[t]=max(tim[t],tim[now]+len[t]);
			cot[p[now][i]]--;
			if(cot[p[now][i]]==0)	q.push(p[now][i]);
		}
	}
	for(int i=1;i<=n;i++){
		rst=max(rst,tim[i]);
	}
	printf("%d",rst);
	return 0;
}
```

