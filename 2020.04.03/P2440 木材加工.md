# [P2440 木材加工](https://www.luogu.com.cn/problem/P2440)

## 题目背景

要保护环境

## 题目描述

木材厂有一些原木，现在想把这些木头切割成一些长度相同的小段木头（木头有可能有剩余），需要得到的小段的数目是给定的。当然，我们希望得到的小段木头越长越好，你的任务是计算能够得到的小段木头的最大长度。木头长度的单位是cm。原木的长度都是正整数，我们要求切割得到的小段木头的长度也是正整数。

例如有两根原木长度分别为11和21，要求切割成到等长的6段，很明显能切割出来的小段木头长度最长为5.

## 输入格式

第一行是两个正整数N和K(1 ≤ N ≤ 100000，1 ≤ K ≤ 100000000)，N是原木的数目，K是需要得到的小段的数目。

接下来的N行，每行有一个1到100000000之间的正整数，表示一根原木的长度。

## 输出格式

能够切割得到的小段的最大长度。如果连1cm长的小段都切不出来，输出”0”。

## 输入输出样例

**输入 #1**复制

```
3 7
232
124
456
```

**输出 #1**复制

```
114
```

***

简单二分查找题。

但要注意：**二分出来满足条件的值不一定是最大值。要继续向后找到第一个不满足条件的值，答案为该值 -1**

例：输入：

```
4 5
621595
4569
12
2345
```

输出：

```
124319
```

如果二分出来第一个值为：`116549`

***

```c++
#include<bits/stdc++.h>
#define ll long long
using namespace std;

int main() {
	ll n,k,a[100010]={0},t=0;
	scanf("%lld %lld",&n,&k);
	for(int i=0;i<n;i++){
		scanf("%lld",&a[i]);
		t+=a[i];
	}
	if(t<k){
		printf("0");
		return 0;
	}
	sort(a,a+n);
	ll l=1,r=a[n-1];
	while(1){
		ll m=(l+r)/2;
		t=0;
		for(int i=0;i<n;i++)	t+=(a[i]/m);
		if(t==k||r-l==1){
			while(++m){
				t=0;
				for(int i=0;i<n;i++)	t+=(a[i]/m);
				if(t<k)	break;
			}
			printf("%lld",m-1);
			break;
		}else if(t>k)	l=m;
		else if(t<k)	r=m;
	}
	return 0;
}

```

